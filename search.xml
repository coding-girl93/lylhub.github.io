<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[再次回来]]></title>
      <url>%2F2016%2F11%2F21%2F%E5%9B%9E%E5%BD%92%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[从搭建博客完毕到现在又很久没有使用博客了，时间过得好快，转眼毕业工作近半年了，总是养不成一个坚持写点东西的习惯，最近在看《当你的才华还撑不起你的梦想时》，书中很多励志文字，但是坚持下来却是最难最难的，就像我写博客永远总是三分钟热度，觉得自己没有东西要写,写不出东西来，其实这也是最大的缺点吧技术不过关。这一次就挑战一下自己，看看能坚持写每天写博客写多久！ 今天先分享一个自己的小目标： 之前搭建博客的时候，弄了一半就没有搭建了，关于评论这一块都没有加上，看上去总是不完美，今天把多说加上了，以后欢迎大家评论指导。不过总感觉界面看起来没有那么漂亮，求各路大神指导啊！！1console.log(&apos;到吗&apos;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular-popups]]></title>
      <url>%2F2016%2F09%2F13%2FAngular-popups%2F</url>
      <content type="text"><![CDATA[基于angularJS的浮层组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript设计模式]]></title>
      <url>%2F2016%2F09%2F08%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[JavaScript设计模式（Design pattern）我们每天都在使用设计模式，但是不了解设计模式的人，可能根本不知道自己已经在使用设计模式了，了解设计模式，有利于提高自己的代码质量。那么什么是设计模式？设计模式可以为我们带来哪些好处呢？ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 设计模式六大原则就像每种语言都有自己的规范，设计模式也遵循自己的原则 开闭原则（OCP：Open Closed Principe） Software entites(classes，modules，functions，etc)，should be open for extension ,but closed for modification. 软件实体（类，模块，方法等等）应当对扩展开发，对修改关闭。 单一职责（SRP:Single Responsibility Principle） A class should have only one reason to change 里氏代换原则（LSP:Leskov Substitution Principle） 依赖倒转原则（DIP:Dependency Inversion Principle） 接口隔离(ISP:Interface Segregation Principle) 迪米特法则(最少知识原则)(PLK :Principle of Least Knowledge) 原则介绍请戳这里; 设计模式分类创建型设计模式Creational 根据创建对象的概念进行分类 工厂方法：Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类。简单点说就是茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。 上栗子： 1234567891011121314151617子类：function CarFactory()&#123; alert(&apos;car&apos;);&#125;function TrucksFactory()&#123; alert(&apos;Trucks&apos;);&#125;工厂类：function Factory(type)&#123; if(type == &apos;car&apos;)&#123; return new CarFactory(); &#125;else if(type == &apos;Trucks&apos;)&#123; return new TrucksFactory(); &#125;&#125;使用：var o = new Factory(&apos;car&apos;); 使用场景 根据不同的环境创建不同的实例对象 对象的构建比较复杂 处理大量有相同属性的小对象 应用原则 单一职责 因为每次扩展都需要修改工厂类，这样违背了开闭原则。 抽象工厂：Abstract Factory 抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。抽象工厂模式就是对功能类单独创建工厂类,这样就不必修改之前的代码，又扩展了功能。 上栗子： 12345678910111213141516171819202122232425function Car()&#123; alert(&apos;car&apos;);&#125;function Truck()&#123; alert(&apos;Truck&apos;);&#125;//直接创建功能类工厂//汽车function CarFactory()&#123;&#125;CarFactory.prototype.produce = function() &#123; return new Car();&#125;//货车function TruckFactory()&#123;&#125;TruckFactory.prototype.produce = function() &#123; return new Truck();&#125;//使用var factory = new TruckFactory();var truck = factory.produce(); 使用场景 在一个继承体系中存在多个等级结构：例如不同的厂家生产car,并且分属各个等级结构中的实现类之间存在着一定的关联或者约束 应用原则 单一原则 开闭原则 建造者：Builder 建造器使得我们仅仅只通过定义对象的类型和内容，就可以去构建复杂的对象，为我们屏蔽了明确创造或者展现对象的过程。 四要素： 产品类、抽象建造者类、建造者类、指导类 上栗子：前面你创建了一个生产保时捷的工厂，生产一台保时捷911需要的主要部件都一样(引擎，轮子，方向盘…)和流程是不变的，变的是引擎，轮子，控制系统等等部件具体实现，这些部件的生产交由具体的builder去生产。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495产品类：function Car() &#123; var _frame, _engine, _wheel; this.setFrame = function (val) &#123; _frame = val; &#125;; this.setEngine = function (val) &#123; _engine = val; &#125;; this.setWheel = function (val) &#123; _wheel = val; &#125;; this.getFrame = function () &#123; return _frame &#125;; this.getEngine = function () &#123; return _engine &#125;; this.getWheel = function () &#123; return _wheel &#125;; this.check = function () &#123; console.log(_frame + &apos;检查完毕&apos;); console.log(_engine + &apos;检查完毕&apos;); console.log(_wheel + &apos;检查完毕&apos;); &#125;;&#125;抽象建造者类：function Builder() &#123; //定义流程的接口 buildFrame、buildEngine、buildWheel、buildCar&#125;具体建造者类：function Builder911() &#123; this.__proto__ = new Builder(); var _car = new Car(); this.buildFrame = function () &#123; console.log(&apos;制造911骨架&apos;); _car.setFrame(&apos;911骨架&apos;); &#125;; this.buildEngine = function () &#123; console.log(&apos;制造911引擎&apos;); _car.setEngine(&apos;911引擎&apos;); &#125;; this.buildWheel = function () &#123; console.log(&apos;制造911轮子&apos;); _car.setWheel(&apos;911轮子&apos;); &#125;; this.buildCar = function () &#123; console.log(&apos;911汽车各部组装完毕&apos;); return _car; &#125;;&#125;function BuilderCayma() &#123; this.__proto__ = new Builder(); var _car = new Car(); this.buildFrame = function () &#123; console.log(&apos;制造Cayma骨架&apos;); _car.setFrame(&apos;Cayma骨架&apos;); &#125;; this.buildEngine = function () &#123; console.log(&apos;制造Cayma引擎&apos;); _car.setEngine(&apos;Cayma引擎&apos;); &#125;; this.buildWheel = function () &#123; console.log(&apos;制造Cayma轮子&apos;); _car.setWheel(&apos;Cayma轮子&apos;); &#125;; this.buildCar = function () &#123; console.log(&apos;Cayma汽车各部组装完毕&apos;); return _car; &#125;;&#125;指导类：function Director(Builder) &#123; //传入具体制造者 var _builder = Builder; this.build = function () &#123; _builder.buildFrame(); _builder.buildEngine(); _builder.buildWheel(); return _builder.buildCar(); &#125;;&#125;使用：var builder911 = new Builder911();var director911 = new Director(builder911);var car911 = director911.build();car911.check(); 使用场景 需要生成的对象具有复杂的内部结构；需要生成的对象内部属性本身相互依赖。 优点 1.建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指导者类中对整体而言可以取得比较好的稳定性。2.建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成。 原型模式 Prototype “四人组”称原型模式是一种基于现有对象模板，通过克隆方式创建对象的模板（《JavaScript设计模式》p70），我们可以认为原型模式是基于原型继承的模式，是一种组合式继承，可以在其中创建对象 上栗子： 12345678基类：var base = function()&#123; this.name = &apos;base&apos;;&#125;子类：var sub = Object.create(base);console.log(sub.name); Object.create(prototype,descriptors):创建一个具有指定原型且可选择性地包含指定属性的对象,实现继承 单例模式 Singleton 单例就是保证一个类只有一个实例 简单单例模式:使用对象字面量的方式创建对象 12345var singleton = &#123; name : &apos;&apos;, age : &apos;&apos;, method: function()&#123;&#125;&#125; 缺点：全局的资源，公共的数据 惰性单例模式：通过闭包设置私有变量，延迟初始化 123456789101112131415161718192021var Singleton = (function () &#123; var instantiated; function init() &#123; /*这里定义单例代码*/ return &#123; publicMethod: function () &#123; console.log(&apos;hello world&apos;); &#125;, publicProperty: &apos;test&apos; &#125;; &#125; return &#123; getInstance: function () &#123; if (!instantiated) &#123; instantiated = init(); &#125; return instantiated; &#125; &#125;;&#125;)(); 分支单体 1234567891011121314151617var Slington = (function()&#123; var def = true; var More = function()&#123; var objA = &#123; //火狐浏览器 内部的一些配置 attr1: &apos;ff attr1&apos;, //属性1 //方法1 &#125; var objB = &#123; //ie浏览器 内部的一些配置 attr2: &apos;ie attr1&apos;, //属性1 //方法1 &#125; &#125; return (def) ? new More().objA : new More().objB;&#125;)(); 结构型设计模式(Structural) 结构型模式关注于对象组成和通常识别的方式实现不同对象直接的关系。 适配器模式（Adapter） 适配器模式是将一个对象的方法或者属性转化为客户希望的另外一个对象的方法或属性，适配器模式使得原本由于接口不兼容而不能一起工作的对象可以一起工作(有种偷梁换柱的感觉奥)。速成包装器(wrapper) 上栗子：猫：会走、会叫（miao）;狗：会走、会叫（wang） 1234567891011121314151617181920212223242526272829303132//猫var Cat = function()&#123;&#125;Cat.prototype.go=function()&#123;&#125;Cat.prototype.miao = function()&#123; console.log(&apos;miao&apos;);&#125;//狗var Dog = function()&#123;&#125;Dog.prototype.go=function()&#123;&#125;Dog.prototype.wang = function()&#123; console.log(&apos;wang&apos;);&#125;// 如果我们想让狗也实现猫的叫声，就需要写一个新的狗的适配器DogAdaptervar DogAdapter = function(dog)&#123; Cat.apply(this); this.dog = dog;&#125;DogAdapter.prototype = new Cat();DogAdapter.prototype.miao = function()&#123; this.dog.wang();&#125;//测试var cat = new Cat();var dog = new Dog();var dogAdapter = new DogAdapter(dog);//原始各自的行为cat.miao();//miaodog.wang();//wang//狗调用猫的叫声，发自己的声音dogAdapter.miao();//wang 桥接模式Bridge 将抽象部分与她的实现部分分离，是他们可以独立的变化 这样说可能有点抽象，下面我们用代码说话，上栗子: 12345678910111213141516171819//常用的ajax请求function sendInfo(element)&#123; var id = element.id; ajax( &quot;GET&quot;,&quot;info.json?id=&quot;+id, function( result )&#123; ... &#125;);&#125;//很多时候我们使用sendInfo方法，每个方法中都有ajax请求，这时你会发现大量重复的代码(当你的代码中超过2处重复的代码时，你就要考虑重构你的代码了,单一职责原则)function sendInfo(elelment)&#123; var id = element.id; callback = function(result)&#123;&#125; ajaxBrige(id,callback);&#125;function ajaxBrige(id,callback)&#123; var id = element.id; ajax( &quot;GET&quot;,&quot;info.json?id=&quot;+id, function( result )&#123; callback(reslut) &#125;);&#125; 优点 接口和实现隔离，实现单一责任 提高可扩充性 实现的细节对用户隐藏 组合模式（Composite） 将对象组合成树形结构以表示整体-部分的管理，组合模式中只有两种类型对象，组合对象，叶子对象 上栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//组合对象function ImagesStore( id )&#123; this.children = []; this.element = document.createElement(&quot;div&quot;); this.element.id = id; this.element.className = &quot;imgs-store&quot;;&#125;ImagesStore.prototype = &#123; constructor ： ImagesStore， add : function( child )&#123; this.children.push( child ); this.element.appendChild( child.getElement() ); &#125;, remove : function( child )&#123; for( var node, i=0; node = this.getChild(i); i++ )&#123; if( node === child )&#123; this.children.splice( i, 1 ); break; &#125; this.element.removeChild( child.getElement() ); &#125; &#125;, getChild : function( i )&#123; return this.children[i]; &#125;, show : function()&#123; this.element.style.display = &apos;&apos;; for( var node, i=0; node = this.getChild(i); i++ )&#123; node.show(); &#125; &#125;, hide : function()&#123; for( var node, i=0; node = this.getChild(i); i++ )&#123; node.hide(); &#125; this.element.style.display = &apos;none&apos;; &#125;, getElement : function()&#123; return this.element; &#125;&#125;//叶子对象function ImageItem( src )&#123; this.element = document.createElement(&quot;img&quot;); this.element.src = src; this.element.className = &quot;img-item&quot;;&#125;ImageItem.prototype = &#123; constructor ： ImagesStore， add : function( child )&#123; throw new Error(&quot;this is image object, no add function&quot;); &#125;, remove : function( child )&#123; throw new Error(&quot;this is image object, no remove function&quot;); &#125;, getChild : function( i )&#123; throw new Error(&quot;this is image object, no getChild function&quot;); &#125;, show : function()&#123; this.element.style.display = &apos;&apos;; &#125;, hide : function()&#123; this.element.style.display = &apos;none&apos;; &#125;, getElement : function()&#123; return this.element; &#125;&#125;//组合var store = new ImagesStore(&quot;first&quot;);store.add( new ImageItem(&quot;/img/1.jpg&quot;) );store.add( new ImageItem(&quot;/img/2.jpg&quot;) ); 使用场景 你想表示对象的部分-整体层次结构时； 你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法） 装饰器模式（Decorator） 在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象。 在没有使用模式之前，对于一个js小白来讲，创建一个父类，通过不同的子类来实现不同的功能，这也是面向对象的思想，思路是正确的，可是你有没有想过后期的维护呢？如果功能少还好，功能很多就要写很多个子类，同时如果需要扩展也要重新定义子类 12345678910//父类var Car = function()&#123;&#125;//不同公共的子类子类var CarWithPowerLocks = function() &#123;...&#125;;var CarWithPowerWindows = function() &#123;...&#125;;var CarWithPowerLocksAndPowerWindows = function() &#123;...&#125;;var CarWithAC = function() &#123;...&#125;;var CarWithACAndPowerLocks = function() &#123;...&#125;;var CarWithACAndPowerWindows = function() &#123;...&#125;;var CarWithACAndPowerLocksAndPowerWindows = function() &#123;...&#125;; 下面使用装饰者模式来拯救你的不可维护的代码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//创建一个基类Carvar Car = functionn()&#123;&#125;Car.prortype=&#123; start: function() &#123; console.log(&apos;伴随着引擎的轰鸣声，车子发动了！&apos;); &#125;, drive: function() &#123; console.log(&apos;走起!&apos;); &#125;, getPrice: function() &#123; return 11000.00; &#125;&#125;//创建装饰者抽象类// 你需要传递一个Car（或者是CarDecorator）才能为它添加功能。var CarDecorator = function(car) &#123; this.car = car;&#125;// CarDecorator 实现相同的接口CarDecorator.prototype = &#123; start: function() &#123; this.car.start(); &#125;, drive: function() &#123; this.car.drive(); &#125;, getPrice: function() &#123; return this.car.getPrice(); &#125;&#125;//具体的装饰者类var PowerLocksDecorator = function(car) &#123; // 这是JavaScript里调用父类构造函数的方式 CarDecorator.call(this, car); console.log(&apos;装配：添加动力锁&apos;);&#125;PowerLocksDecorator.prototype = new CarDecorator();PowerLocksDecorator.prototype.drive = function() &#123; // 你可以这么写 this.car.drive(); // 或者你可以调用父类的drive方法： // CarDecorator.prototype.drive.call(this); console.log(&apos;车门自动上锁&apos;);&#125;var PowerWindowsDecorator = function(car) &#123; CarDecorator.call(this, car); console.log(&apos;装配：添加动力表盘&apos;);&#125;PowerWindowsDecorator.prototype = new CarDecorator();var ACDecorator = function(car) &#123; CarDecorator.call(this, car); console.log(&apos;装配：添加空调&apos;);&#125;ACDecorator.prototype = new CarDecorator();ACDecorator.prototype.start = function() &#123; this.car.start(); console.log(&apos;冷风吹起来&apos;);&#125; 这样我们每次新增功能，都可以确保基类和装饰类不改变，只需要通过具体的装饰类来扩展功能就好。感觉和组合模式很像，组合模式侧重部分-整体，将部分注入到整体中，而装饰者模式是通过具体的装饰者类实现角色的基本功能并添加额外功能 看完栗子，来总结一下： 装饰者模式的几大要素 角色（Component）:定义了接口，规范准备接受的对象（Car） 装饰角色（Decorator）：持有角色（Component）的实例，定义与角色一致的接口（CarDecorator） 具体装饰着（PowerLocksDecorator）:负责给角色添加附加功能 优点 装饰类和被装饰类可以独立发展，不会相互耦合 装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。就增加功能来说，装饰器模式相比生成子类更为灵活。 使用场景 扩展一个类的功能。 动态增加功能，动态撤销。 使用了 开闭原则 这里讲解很精彩 外观模式（Facede） 门面模式本质是实现一个简单的统一接口来处理对各个子系统接口的处理和调用 这里我们来回忆一下之前说过的桥接模式，两者感觉差不多，实际侧重点并不相同。桥接模式侧重于各个类相互独立，而外观模式侧重于接口和内部实现的分离，我们只需要知道怎样调用接口无需知道内部的实现过程。 上栗子：模拟电脑启动，假设电脑启动顺序：启动CPU，启动内存，启动硬盘，加载数据等。 123456789101112131415161718192021222324252627282930// 外观模式 function CPU() &#123; this.startup = function () &#123; console.log(&quot;启动CPU&quot;); &#125;;&#125;function Memory() &#123; this.startup = function () &#123; console.log(&quot;启动Memory&quot;); &#125;;&#125;function Disk() &#123; this.startup = function () &#123; console.log(&quot;启动Disk&quot;); &#125;;&#125;function Computer() &#123; var _cpu, _memory, _disk; _cpu = new CPU(); _memory = new Memory(); _disk = new Disk(); this.start = function () &#123; _cpu.startup(); _memory.startup(); _disk.startup(); &#125;&#125;computer = new Computer();computer.start(); 优点 1.减少系统相互依赖。2.提高灵活性。2.提高了安全性。 使用场景 1.为复杂的模块或子系统提供外界访问的模块。2.客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 享元模式（Flyweight）​ 代理模式（Proxy） 行为设计模式（Behavioral） 解释器（Interpreter） 模板方法（Template Method） 职责链（Responsibility） 命令（Command） 迭代器（Iterator） 中介者（Mediator） 观察者（Observe） 状态（State） 策略（Strategy） 访问者（Visitor）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bookmarks使用]]></title>
      <url>%2F2016%2F09%2F01%2Fbookmarks%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[bookmarks可以很便利的存储、管理我们日常使用的网站，一般情况下，我们仅仅是把自己的网站存在自己的bookmarks下面，以便自己日后查看。在团队中，多多向别人学习，看看别人的代码，瞅瞅别人经常浏览的网站，通过这种方式找到学习的方向，提升自己，特别是对菜鸟，会提供方向性的指导，多浏览一下质量高的网站，对自己的提高帮助很大的。 安装npm install netscape-bookmarks npm install netscape-bookmarks 使用 12345678var netscape = require(&apos;netscape-bookmarks&apos;);var bookmarks = &#123; &apos;Dave Eddy&apos;: &apos;http://www.daveeddy.com&apos;, &apos;Perfume Global&apos;: &apos;http://www.perfume-global.com&apos;&#125;;var html = netscape(bookmarks));console.log(html); copy html格式文件，html标签说明 123456789101112131415161718192021&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt;&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;&lt;H1&gt;Bookmarks Menu&lt;/H1&gt;&lt;DL&gt;&lt;p&gt; // 书签列表 &lt;DT&gt;&lt;A HREF=&quot;http://www.daveeddy.com&quot;&gt;Dave Eddy&apos;s Blog&lt;/a&gt; // 书签项 &lt;DT&gt;&lt;A HREF=&quot;http://www.perfume-global.com/&quot;&gt;Perfume Global&lt;/a&gt; &lt;DT&gt;&lt;H3&gt;Unfiled&lt;/H3&gt; // 书签文件夹 &lt;DL&gt;&lt;p&gt; &lt;DT&gt;&lt;A HREF=&quot;http://twitter.com&quot;&gt;Twitter&lt;/a&gt; // 书签项 &lt;/DL&gt;&lt;p&gt; &lt;DT&gt;&lt;H3&gt;Second Folder&lt;/H3&gt; &lt;DL&gt;&lt;p&gt; &lt;DT&gt;&lt;H3&gt;Nested Folders!&lt;/H3&gt; &lt;DL&gt;&lt;p&gt; &lt;DT&gt;&lt;A HREF=&quot;http://www.youtube.com&quot;&gt;YouTube&lt;/a&gt; &lt;DT&gt;&lt;A HREF=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt; &lt;/DL&gt;&lt;p&gt; &lt;/DL&gt;&lt;p&gt; &lt;DT&gt;&lt;A HREF=&quot;http://www.tekzoned.com&quot; ADD_DATE=&quot;1357547237&quot; LAST_VISIT=&quot;1357547238&quot; LAST_MODIFIED=&quot;1357547239&quot;&gt;TekZoned&lt;/a&gt;&lt;/DL&gt;&lt;p&gt; 浏览器-书签管理器-从html文件导入书签]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript模板引擎]]></title>
      <url>%2F2016%2F08%2F31%2FjavascriptTemplate%2F</url>
      <content type="text"><![CDATA[简介 javascript模板引擎作为数据与界面分离工作中的重要角色，下面我们从模板引擎的实现原理以及目前流行的模板引擎，模板引擎的优势来介绍一下 原理虽然每个引擎从模板语法、语法解析、变量赋值、字符串拼接的实现方式各有所不同，但关键的渲染原理仍然是动态执行 javascript 字符串。 优势 js模板的本质是 变静为动 视图和代码逻辑分离、低耦合 可拓展、可维护、开发效率高 代码可读性 目前流行的 JavaScript模板引擎 artTemplate(腾讯) Mustache baiduTemplate(百度) juicer(淘宝) Underscore Templates Embedded JS Templates等等，可以参考这里五款流行的JavaScript模板引擎;javascript各种模板引擎; 使用 以 （EJS）Embedded JS Templates为例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用hexo+GitHub搭建自己的博客]]></title>
      <url>%2F2016%2F08%2F31%2F%E4%BD%BF%E7%94%A8hexo-GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[作为一名前端程序媛，没有自己的博客，听起来是不是很low！对，你没有听错，我确实没有亲自搭建过自己的博客，就在2016年8月30日，偶尔阅读前端工程师必备技能的时候，发现了搭建自己博客这个东西，于是决定搭建一个博客来存储自己的知识总结，以便形成自己的知识体系。这之前使用github我的github地址管理自己的代码（其实写的比较少）,而且很多知识性的总结写在里面不是很方便阅读。博客可以很方便的把知识总结存储起来。以前用过CSDN,用于存储知识还是可以，但是本地化和主题等就没有了，毕竟是用人家的网站，要想个性化还是要自己亲自去搭建一个高大上的网站吧。你正在浏览这个博客网站，耗费了本姑娘很长时间才搭建好的！！这里有一篇很详细的教程：使用 GitHub Pages + Hexo 基础教程;因为还没有写过正式的博客，对于hexo的使用还不熟悉，后面将更新我的的使用心得。]]></content>
    </entry>

    
  
  
</search>
