<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[移动端input获取焦点后破坏fixed定位的元素]]></title>
      <url>%2F2017%2F02%2F21%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFinput%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E5%90%8E%E7%A0%B4%E5%9D%8Ffixed%E5%AE%9A%E4%BD%8D%2F</url>
      <content type="text"><![CDATA[h5页面中，经常会有这样的场景在一个fixed定位的元素上输入信息，但是移动端input会唤起软键盘，软键盘会更改视口viewport大小，导致fixed定位的元素被破坏 html 123456789101112131415&lt;body&gt; &lt;section class="container"&gt; &lt;img src="http://wd.geilicdn.com/vshop164096035-145199488880-6520909.jpg?w=460&amp;h=675?w=750"&gt; &lt;img src="http://wd.geilicdn.com/vshop164096035-145199488880-6520909.jpg?w=460&amp;h=675?w=750"&gt; &lt;img src="http://wd.geilicdn.com/vshop164096035-145199488880-6520909.jpg?w=460&amp;h=675?w=750"&gt; &lt;img src="http://wd.geilicdn.com/vshop164096035-145199488880-6520909.jpg?w=460&amp;h=675?w=750"&gt; &lt;!-- &lt;div class="button"&gt;点击弹出浮层&lt;/div&gt; --&gt; &lt;/section&gt; &lt;section class="layer"&gt; &lt;section class="wrap"&gt; 获取焦点&lt;input type="text" name="" value=""&gt; &lt;/section&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; less 123456789101112131415161718192021.layer&#123; position: fixed; top:0; bottom: 0; right: 0; left: 0; background-color: rgba(0, 0, 0, 0.7); .wrap&#123; height: 80px; position: fixed; bottom: 0; left: 0; right: 0; background-color: red; input&#123; width: 200px; height: 40px; border: 1px solid #e8e8e8; &#125; &#125;&#125; 页面 移动端input获取焦点后 会发现原本固定在底部的元素被破坏掉了，页面结构发生了变化问题来了，什么原因导致fixed元素被破坏了呢？ 我们知道fixed是相对于视口viewport进行定位的（fixed戳这里、点这里） 当获取焦点唤起小键盘后，viewport被破坏，而html,body的高度并没有改变(内容的高度大于viewport的高度)页面依旧可以滚动，但是fixed定位的元素只有viewport的大小 设置html,body的高度height：100%（内容高度==viewport高度即可） 1234html,body&#123; height: 100%; overflow: auto;&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网页版录音]]></title>
      <url>%2F2016%2F12%2F23%2F%E7%BD%91%E9%A1%B5%E7%89%88%E5%AE%9E%E7%8E%B0%E5%BD%95%E9%9F%B3%2F</url>
      <content type="text"><![CDATA[使用网页实现录音功能 record.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220(function (window) &#123;//兼容window.URL = window.URL || window.webkitURL;navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;var HZRecorder = function (stream, config) &#123; config = config || &#123;&#125;; config.sampleBits = config.sampleBits || 8; //采样数位 8, 16 config.sampleRate = config.sampleRate || (44100 / 6); //采样率(1/6 44100) //创建一个音频环境对象 audioContext = window.AudioContext || window.webkitAudioContext; var context = new audioContext(); //将声音输入这个对像 var audioInput = context.createMediaStreamSource(stream); // //设置音量节点 // var volume = context.createGain(); // audioInput.connect(volume); // // //创建缓存，用来缓存声音 // var bufferSize = 4096; // // // 创建声音的缓存节点，createScriptProcessor方法的 // // 第二个和第三个参数指的是输入和输出都是双声道。 var recorder = context.createScriptProcessor(4096, 1, 1); var audioData =&#123; size: 0 //录音文件长度 , buffer: [] //录音缓存 , inputSampleRate: context.sampleRate //输入采样率 , inputSampleBits: 16 //输入采样数位 8, 16 , outputSampleRate: config.sampleRate //输出采样率 , oututSampleBits: config.sampleBits //输出采样数位 8, 16 , input: function (data) &#123; this.buffer.push(new Float32Array(data)); this.size += data.length; &#125; , compress: function () &#123; //合并压缩 //合并 var data = new Float32Array(this.size); var offset = 0; for (var i = 0; i &lt; this.buffer.length; i++) &#123; data.set(this.buffer[i], offset); offset += this.buffer[i].length; &#125; //压缩 var compression = parseInt(this.inputSampleRate / this.outputSampleRate); var length = data.length / compression; var result = new Float32Array(length); var index = 0, j = 0; while (index &lt; length) &#123; result[index] = data[j]; j += compression; index++; &#125; return result; &#125; , encodeWAV: function () &#123; var sampleRate = Math.min(this.inputSampleRate, this.outputSampleRate); var sampleBits = Math.min(this.inputSampleBits, this.oututSampleBits); var bytes = this.compress(); var dataLength = bytes.length * (sampleBits / 8); var buffer = new ArrayBuffer(44 + dataLength); var data = new DataView(buffer); var channelCount = 1;//单声道 var offset = 0; var writeString = function (str) &#123; for (var i = 0; i &lt; str.length; i++) &#123; data.setUint8(offset + i, str.charCodeAt(i)); &#125; &#125;; // 资源交换文件标识符 writeString('RIFF'); offset += 4; // 下个地址开始到文件尾总字节数,即文件大小-8 data.setUint32(offset, 36 + dataLength, true); offset += 4; // WAV文件标志 writeString('WAVE'); offset += 4; // 波形格式标志 writeString('fmt '); offset += 4; // 过滤字节,一般为 0x10 = 16 data.setUint32(offset, 16, true); offset += 4; // 格式类别 (PCM形式采样数据) data.setUint16(offset, 1, true); offset += 2; // 通道数 data.setUint16(offset, channelCount, true); offset += 2; // 采样率,每秒样本数,表示每个通道的播放速度 data.setUint32(offset, sampleRate, true); offset += 4; // 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8 data.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), true); offset += 4; // 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8 data.setUint16(offset, channelCount * (sampleBits / 8), true); offset += 2; // 每样本数据位数 data.setUint16(offset, sampleBits, true); offset += 2; // 数据标识符 writeString('data'); offset += 4; // 采样数据总数,即数据总大小-44 data.setUint32(offset, dataLength, true); offset += 4; // 写入采样数据 if (sampleBits === 8) &#123; for (var i = 0; i &lt; bytes.length; i++, offset++) &#123; var s = Math.max(-1, Math.min(1, bytes[i])); var val = s &lt; 0 ? s * 0x8000 : s * 0x7FFF; val = parseInt(255 / (65535 / (val + 32768))); data.setInt8(offset, val, true); &#125; &#125; else &#123; for (var i = 0; i &lt; bytes.length; i++, offset += 2) &#123; var s = Math.max(-1, Math.min(1, bytes[i])); data.setInt16(offset, s &lt; 0 ? s * 0x8000 : s * 0x7FFF, true); &#125; &#125; return new Blob([data], &#123; type: 'audio/wav' &#125;); &#125; &#125;; //开始录音 this.start = function () &#123; audioInput.connect(recorder); recorder.connect(context.destination); &#125;; //停止 this.stop = function () &#123; recorder.disconnect(); &#125;; //获取音频文件 this.getBlob = function () &#123; this.stop(); return audioData.encodeWAV(); &#125;; //回放 this.play = function (audio) &#123; audio.src = window.URL.createObjectURL(this.getBlob()); &#125;; //上传 this.upload = function (url, callback) &#123; var fd = new FormData(); fd.append('audioData', this.getBlob()); console.log(fd.get('audioData')); var xhr = new XMLHttpRequest(); if (callback) &#123; xhr.upload.addEventListener('progress', function (e) &#123; callback('uploading', e); &#125;, false); xhr.addEventListener('load', function (e) &#123; callback('ok', e); &#125;, false); xhr.addEventListener('error', function (e) &#123; callback('error', e); &#125;, false); xhr.addEventListener('abort', function (e) &#123; callback('cancel', e); &#125;, false); &#125; xhr.open('POST', url); xhr.send(fd); &#125;; //音频采集 recorder.onaudioprocess = function (e) &#123; audioData.input(e.inputBuffer.getChannelData(0)); //record(e.inputBuffer.getChannelData(0)); &#125;;&#125;;//抛出异常HZRecorder.throwError = function (message) &#123; throw new function () &#123; this.toString = function () &#123; return message; &#125;;&#125;;&#125;;//是否支持录音HZRecorder.canRecording = (navigator.getUserMedia != null);alert(HZRecorder.canRecording)//获取录音机HZRecorder.get = function (callback, config) &#123; if (callback) &#123; if (navigator.getUserMedia) &#123; navigator.getUserMedia( &#123; audio: true &#125; //只启用音频 , function (stream) &#123; var rec = new HZRecorder(stream, config); callback(rec); &#125; , function (error) &#123; switch (error.code || error.name) &#123; case 'PERMISSION_DENIED': case 'PermissionDeniedError': HZRecorder.throwError('用户拒绝提供信息。'); alert('用户拒绝提供信息。') break; case 'NOT_SUPPORTED_ERROR': case 'NotSupportedError': HZRecorder.throwError('&lt;a href="http://www.it165.net/edu/ewl/" target="_blank" class="keylink"&gt;浏览器&lt;/a&gt;不支持硬件设备。'); break; case 'MANDATORY_UNSATISFIED_ERROR': case 'MandatoryUnsatisfiedError': HZRecorder.throwError('无法发现指定的硬件设备。'); break; default: HZRecorder.throwError('无法打开麦克风。异常信息:' + (error.code || error.name)); break; &#125; &#125;); &#125; else &#123; HZRecorder.throwErr('当前&lt;a href="http://www.it165.net/edu/ewl/" target="_blank" class="keylink"&gt;浏览器&lt;/a&gt;不支持录音功能。'); return; &#125; &#125;&#125;;window.HZRecorder = HZRecorder;&#125;)(window); html 12345&lt;audio controls autoplay&gt;&lt;/audio&gt;&lt;input onclick='startRecording()' type='button' value='录音' /&gt;&lt;input onclick='stopRecording()' type='button' value='停止' /&gt;&lt;input onclick='playRecording()' type='button' value='播放' /&gt;&lt;input onclick='uploadAudio()' type='button' value='提交' /&gt; js 123456789101112131415161718192021222324252627282930313233var recorder; var audio = document.querySelector('audio'); function startRecording() &#123; HZRecorder.get(function (rec) &#123; recorder = rec; recorder.start(); &#125;); // recorder.connect(context.destination); &#125;// function obtainRecord()&#123;// var record = recorder.getBlob();// debugger;// &#125;; function stopRecording()&#123; recorder.stop(); &#125;; function playRecording()&#123; recorder.play(audio); &#125;; function uploadAudio()&#123; recorder.upload('',function()&#123; &#125;) &#125; 注意：只适用于html网页访问，移动端不适用哦原因请见：https://segmentfault.com/q/1010000005952605 参考资料：http://blog.csdn.net/gf771115/article/details/45643271 如果你读到这里了，来，摸摸头！好运~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊css的单位像素]]></title>
      <url>%2F2016%2F11%2F25%2Fcss%E5%8D%95%E4%BD%8D%2F</url>
      <content type="text"><![CDATA[最近在看《CSS揭秘》，看了没超过10页就走不动了，最基础的单位我居然也不知道，真的是前端小渣渣。。。 css单位 px相信你对px一定不陌生：相对长度单位，像素px是相对于显示器屏幕分辨率而言的（引自css2.0手册）。 试想一下，你开发页面全部用px这种精确值来设置，自适应、弹性布局怎么办？修改一个地方，整体布局都要修改，牵一发而动全身，这就违背了DRY(Don’t Reapet Yourself)原则， emcss强大的em remcss3引入的单位]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React+Redux]]></title>
      <url>%2F2016%2F11%2F24%2FReact%2BRedux%2F</url>
      <content type="text"><![CDATA[Redux+React实现 上一篇写了一个react实现组件直接的通信，随着react的流行，越来越多的前端爱好者开始使用它，作为前端小白，我也跟着潮流来了，使用react构建大型应用，必不可少的就是一个好的前端架构来管理你的数据，例如flux、redux,这里我写了一个简单的redux工作流程，仅仅是为了自己了解redux的工作机制，大神请绕过~~ redux中文文档 redux英文文档 从图中可以看出 react component的改变是通过store来驱动的，我们从view层看代码结构然后依次类推 index.js 1234567891011121314151617181920 import &#123;createStore,&#125; from 'redux' import reducers from './reducers/reducers.js' import ReactDOM from 'react-dom' import React from 'react' import &#123; Provider&#125; from 'react-redux' import App from './components/app.jsx' let store = createStore(reducers) class Index extends React.Component&#123; render()&#123; return( &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt; ) &#125; &#125;ReactDOM.render(&lt;Index/&gt;,document.getElementById('root')) Provider Provider是中间件，他是在原有 App Container 上面再包一层，他的作用就是接收 store 里面的 store 作为 props，将store放在context里，给下面的connect用的。 我们看到引入了一个reducers ，下面看看这个是怎么实现的 Reducer reduces.js 123456789101112131415161718import &#123;CLICK_TEXT,CLICK_BUTTON&#125; from '../actions/actions.js'export default function myApp(state=&#123;text:"Hello"&#125;,action)&#123; switch (action.type) &#123; case CLICK_TEXT: return &#123; text:state.text=='Hello'?'在coding的姑娘':'Hello' &#125; case CLICK_BUTTON: return&#123; text:'有一个姑娘在coding' &#125; default: return state &#125;&#125; action 只是说明了要去做什么，和做这件事情需要的参数值。具体去改变 store 中的 state 是由 reducer 来做的。reducer 其实是一个包含 switch 的函数，前面不是说组件触发的 action 会传递到 reducer，reducer 接收这个参数 action，他通过 switch(action.type) 然后做不同操作，前面说了，这个 type 是指令的标识，reducer 根据这个标识来作出不同的操作。这个操作是什么呢？reducer 还接收另一个参数 state，这个是旧的 state。从 action 里面还可以获取到做这个操作需要的 参数值。这个操作其实就是对原有的 state 和 从 action 中的到的值，来进行操作（结合，删除，…）然后返回一个 新的 state 到 store。 Action在看actions.js 1234567891011121314export const CLICK_TEXT ='CLICK_TEXT'export const CLICK_BUTTON = 'CLICK_BUTTON'export function clickText(text)&#123; return&#123; type:CLICK_TEXT, text &#125;&#125;export function clickButton() &#123; return&#123; type:CLICK_BUTTON &#125;&#125; action 可以理解为一种指令，store 数据的唯一由来就是 action，action 是一个对象，它需要至少一个元素，type，type 是这个指令的唯一标识，其它元素是传送这个指令的 state 值 最后看容器组件是怎样把视图和行为结合在一起的 App.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React from 'react'import &#123;createStore,bindActionCreators&#125; from 'redux'import &#123; Provider,connect&#125; from 'react-redux'import &#123;clickText,clickButton&#125; from '../actions/actions.js'class Hello extends React.Component &#123; constructor(props) &#123; super(props) &#125; handleClick=()=&gt;&#123; this.props.actions.clickText() &#125; render()&#123; return( &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&#123;this.props.text&#125;&lt;/h1&gt; ) &#125;&#125;class Change extends React.Component&#123; constructor(props)&#123; super(props) &#125; handleClick=()=&gt;&#123; this.props.actions.clickButton() &#125; render()&#123; return( &lt;button onClick=&#123;this.handleClick&#125;&gt;点我看看&lt;/button&gt; ) &#125;&#125;class App extends React.Component &#123; constructor(props) &#123; super(props) &#125; render()&#123; const &#123;actions,text&#125; = this.props return ( &lt;div&gt; &lt;Hello actions=&#123;actions&#125; text=&#123;text&#125;/&gt; &lt;Change actions=&#123;actions&#125;/&gt; &lt;/div&gt; ) &#125;&#125;function mapStateToProps(state)&#123; return &#123;text:state.text&#125;&#125;function mapDispatchToProps(dispatch)&#123; return&#123; actions:bindActionCreators(&#123;clickText:clickText,clickButton:clickButton&#125;,dispatch) &#125;&#125;App= connect(mapStateToProps,mapDispatchToProps)(App)export default App connect这个组件才是真正连接 Redux 和 React，他包在我们的容器组件的外一层，他接收上面 Provider 提供的 store 里面的 state 和 dispatch，传给一个构造函数，返回一个对象，以属性形式床给我们的容器组件。 如果你有耐心看到这里，你就很流弊啦，对比纯react的方式实现，你会发现，使用redux代码多了不是一点半点，真的有必要这样么？答案当然是：看你的项目需求~~~如果你的项目没有大量的数据交互，组件通信，你完全可以只用React，但是如果有的话，你会发现你要手动的管理state,对于后期维护很难，姑娘现在就遇到了这样的问题，代码初期考虑到学习成本，没有使用Redux,导致现在每个父组件一堆state要手动管理，重构起来简直不想多看一眼。 参考1参考2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React组件通信]]></title>
      <url>%2F2016%2F11%2F24%2FReact%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[React实现组件直接通信 场景：一个显示文本的组件Hello，一个点击按钮组件Change，显示文本组件可以通过点击事件替换文本，点击按钮组件可以通过点击将显示文本组件的文本替换掉，两个组件直接是怎样通信的呢？ 代码：不考虑Change组件，我们会这样实现Hello组件 123456789101112131415161718class Hello extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; text:'hello' &#125; &#125; handleClick=()=&gt;&#123; let text = this.state.text; let newtext= (text=='hello' )? '在coding的姑娘':'hello' this.setState(&#123;text:newtext&#125;) &#125; render()&#123; return( &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&#123;this.state.text&#125;&lt;/h1&gt; ) &#125;&#125; 但是现在，我们要通过另外一个组件来更改text，这就需要一个父组件App来里text，Change组件和Hello组件直接的通信就要利用父组件的props 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Hello组件class Hello extends React.Component &#123; constructor(props) &#123; super(props) &#125; handleClick=()=&gt;&#123; this.props.onClickText() &#125; render()&#123; return( &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&#123;this.props.text&#125;&lt;/h1&gt; ) &#125;&#125;//Change组件class Change extends React.Component &#123; constructor(props) &#123; super(props) &#125; handleClick= ()=&gt;&#123; this.props.onClickButton() &#125; render()&#123; return( &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt; ) &#125;&#125;//App组件class App extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123; text:'hello' &#125; &#125; handleClickText=()=&gt;&#123; let text = this.state.text; let newtext= (text=='hello' )? '在coding的姑娘':'hello' this.setState(&#123;text:newtext&#125;) &#125; handleClickButton=()=&gt;&#123; this.setState(&#123;text:'姑娘你点击了按钮'&#125;) &#125; render()&#123; return( &lt;div&gt; &lt;Hello text=&#123;this.state.text&#125; onClickText=&#123;this.handleClickText&#125;/&gt; &lt;Change onClickButton=&#123;this.handleClickButton&#125;/&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React踩过的坑]]></title>
      <url>%2F2016%2F11%2F21%2FReact%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[setState延迟 分页操作，点击下一页，第一次点击无效，第二次点击生效 123this.setState(&#123;firstRow:(page-1)*pageSize&#125;,()=&gt;&#123; this.refresh() &#125;) 利用setState的回调，等到状态更改成功之后再操作 列表页删除一项后，列表页不能实时刷新原因：删除操作后，后端可能还没处理好，就重新拉取数据，导致数据没有变化 通过设置延迟 1setTimeout(this.refresh,1000) 或者将列表缓存到数组中，直接对数组进行操作，删除后无需再次拉取数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular-popups]]></title>
      <url>%2F2016%2F09%2F13%2FAngular-popups%2F</url>
      <content type="text"><![CDATA[基于angularJS的浮层组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript设计模式]]></title>
      <url>%2F2016%2F09%2F08%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[JavaScript设计模式（Design pattern） 我们每天都在使用设计模式，但是不了解设计模式的人，可能根本不知道自己已经在使用设计模式了，了解设计模式，有利于提高自己的代码质量。那么什么是设计模式？设计模式可以为我们带来哪些好处呢？ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 设计模式六大原则 就像每种语言都有自己的规范，设计模式也遵循自己的原则 开闭原则（OCP：Open Closed Principe） Software entites(classes，modules，functions，etc)，should be open for extension ,but closed for modification. 软件实体（类，模块，方法等等）应当对扩展开发，对修改关闭。 单一职责（SRP:Single Responsibility Principle） A class should have only one reason to change 里氏代换原则（LSP:Leskov Substitution Principle） 依赖倒转原则（DIP:Dependency Inversion Principle） 接口隔离(ISP:Interface Segregation Principle) 迪米特法则(最少知识原则)(PLK :Principle of Least Knowledge) 原则介绍请戳这里; 设计模式分类创建型设计模式Creational 根据创建对象的概念进行分类 工厂方法：Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类。简单点说就是茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。 上栗子： 1234567891011121314151617子类：function CarFactory()&#123; alert('car');&#125;function TrucksFactory()&#123; alert('Trucks');&#125;工厂类：function Factory(type)&#123; if(type == 'car')&#123; return new CarFactory(); &#125;else if(type == 'Trucks')&#123; return new TrucksFactory(); &#125;&#125;使用：var o = new Factory('car'); 使用场景 根据不同的环境创建不同的实例对象 对象的构建比较复杂 处理大量有相同属性的小对象 应用原则 单一职责 因为每次扩展都需要修改工厂类，这样违背了开闭原则。 抽象工厂：Abstract Factory 抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。抽象工厂模式就是对功能类单独创建工厂类,这样就不必修改之前的代码，又扩展了功能。 上栗子： 12345678910111213141516171819202122232425function Car()&#123; alert('car');&#125;function Truck()&#123; alert('Truck');&#125;//直接创建功能类工厂//汽车function CarFactory()&#123;&#125;CarFactory.prototype.produce = function() &#123; return new Car();&#125;//货车function TruckFactory()&#123;&#125;TruckFactory.prototype.produce = function() &#123; return new Truck();&#125;//使用var factory = new TruckFactory();var truck = factory.produce(); 使用场景 在一个继承体系中存在多个等级结构：例如不同的厂家生产car,并且分属各个等级结构中的实现类之间存在着一定的关联或者约束 应用原则 单一原则 开闭原则 建造者：Builder 建造器使得我们仅仅只通过定义对象的类型和内容，就可以去构建复杂的对象，为我们屏蔽了明确创造或者展现对象的过程。 四要素： 产品类、抽象建造者类、建造者类、指导类 上栗子：前面你创建了一个生产保时捷的工厂，生产一台保时捷911需要的主要部件都一样(引擎，轮子，方向盘…)和流程是不变的，变的是引擎，轮子，控制系统等等部件具体实现，这些部件的生产交由具体的builder去生产。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495产品类：function Car() &#123; var _frame, _engine, _wheel; this.setFrame = function (val) &#123; _frame = val; &#125;; this.setEngine = function (val) &#123; _engine = val; &#125;; this.setWheel = function (val) &#123; _wheel = val; &#125;; this.getFrame = function () &#123; return _frame &#125;; this.getEngine = function () &#123; return _engine &#125;; this.getWheel = function () &#123; return _wheel &#125;; this.check = function () &#123; console.log(_frame + '检查完毕'); console.log(_engine + '检查完毕'); console.log(_wheel + '检查完毕'); &#125;;&#125;抽象建造者类：function Builder() &#123; //定义流程的接口 buildFrame、buildEngine、buildWheel、buildCar&#125;具体建造者类：function Builder911() &#123; this.__proto__ = new Builder(); var _car = new Car(); this.buildFrame = function () &#123; console.log('制造911骨架'); _car.setFrame('911骨架'); &#125;; this.buildEngine = function () &#123; console.log('制造911引擎'); _car.setEngine('911引擎'); &#125;; this.buildWheel = function () &#123; console.log('制造911轮子'); _car.setWheel('911轮子'); &#125;; this.buildCar = function () &#123; console.log('911汽车各部组装完毕'); return _car; &#125;;&#125;function BuilderCayma() &#123; this.__proto__ = new Builder(); var _car = new Car(); this.buildFrame = function () &#123; console.log('制造Cayma骨架'); _car.setFrame('Cayma骨架'); &#125;; this.buildEngine = function () &#123; console.log('制造Cayma引擎'); _car.setEngine('Cayma引擎'); &#125;; this.buildWheel = function () &#123; console.log('制造Cayma轮子'); _car.setWheel('Cayma轮子'); &#125;; this.buildCar = function () &#123; console.log('Cayma汽车各部组装完毕'); return _car; &#125;;&#125;指导类：function Director(Builder) &#123; //传入具体制造者 var _builder = Builder; this.build = function () &#123; _builder.buildFrame(); _builder.buildEngine(); _builder.buildWheel(); return _builder.buildCar(); &#125;;&#125;使用：var builder911 = new Builder911();var director911 = new Director(builder911);var car911 = director911.build();car911.check(); 使用场景 需要生成的对象具有复杂的内部结构；需要生成的对象内部属性本身相互依赖。 优点 1.建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指导者类中对整体而言可以取得比较好的稳定性。2.建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成。 原型模式 Prototype “四人组”称原型模式是一种基于现有对象模板，通过克隆方式创建对象的模板（《JavaScript设计模式》p70），我们可以认为原型模式是基于原型继承的模式，是一种组合式继承，可以在其中创建对象 上栗子： 12345678基类：var base = function()&#123; this.name = 'base';&#125;子类：var sub = Object.create(base);console.log(sub.name); Object.create(prototype,descriptors):创建一个具有指定原型且可选择性地包含指定属性的对象,实现继承 单例模式 Singleton 单例就是保证一个类只有一个实例 简单单例模式:使用对象字面量的方式创建对象 12345var singleton = &#123; name : '', age : '', method: function()&#123;&#125;&#125; 缺点：全局的资源，公共的数据 惰性单例模式：通过闭包设置私有变量，延迟初始化 123456789101112131415161718192021var Singleton = (function () &#123; var instantiated; function init() &#123; /*这里定义单例代码*/ return &#123; publicMethod: function () &#123; console.log('hello world'); &#125;, publicProperty: 'test' &#125;; &#125; return &#123; getInstance: function () &#123; if (!instantiated) &#123; instantiated = init(); &#125; return instantiated; &#125; &#125;;&#125;)(); 分支单体 1234567891011121314151617var Slington = (function()&#123; var def = true; var More = function()&#123; var objA = &#123; //火狐浏览器 内部的一些配置 attr1: 'ff attr1', //属性1 //方法1 &#125; var objB = &#123; //ie浏览器 内部的一些配置 attr2: 'ie attr1', //属性1 //方法1 &#125; &#125; return (def) ? new More().objA : new More().objB;&#125;)(); 结构型设计模式(Structural) 结构型模式关注于对象组成和通常识别的方式实现不同对象直接的关系。 适配器模式（Adapter） 适配器模式是将一个对象的方法或者属性转化为客户希望的另外一个对象的方法或属性，适配器模式使得原本由于接口不兼容而不能一起工作的对象可以一起工作(有种偷梁换柱的感觉奥)。速成包装器(wrapper) 上栗子：猫：会走、会叫（miao）;狗：会走、会叫（wang） 1234567891011121314151617181920212223242526272829303132//猫var Cat = function()&#123;&#125;Cat.prototype.go=function()&#123;&#125;Cat.prototype.miao = function()&#123; console.log('miao');&#125;//狗var Dog = function()&#123;&#125;Dog.prototype.go=function()&#123;&#125;Dog.prototype.wang = function()&#123; console.log('wang');&#125;// 如果我们想让狗也实现猫的叫声，就需要写一个新的狗的适配器DogAdaptervar DogAdapter = function(dog)&#123; Cat.apply(this); this.dog = dog;&#125;DogAdapter.prototype = new Cat();DogAdapter.prototype.miao = function()&#123; this.dog.wang();&#125;//测试var cat = new Cat();var dog = new Dog();var dogAdapter = new DogAdapter(dog);//原始各自的行为cat.miao();//miaodog.wang();//wang//狗调用猫的叫声，发自己的声音dogAdapter.miao();//wang 桥接模式Bridge 将抽象部分与她的实现部分分离，是他们可以独立的变化 这样说可能有点抽象，下面我们用代码说话，上栗子: 12345678910111213141516171819//常用的ajax请求function sendInfo(element)&#123; var id = element.id; ajax( "GET","info.json?id="+id, function( result )&#123; ... &#125;);&#125;//很多时候我们使用sendInfo方法，每个方法中都有ajax请求，这时你会发现大量重复的代码(当你的代码中超过2处重复的代码时，你就要考虑重构你的代码了,单一职责原则)function sendInfo(elelment)&#123; var id = element.id; callback = function(result)&#123;&#125; ajaxBrige(id,callback);&#125;function ajaxBrige(id,callback)&#123; var id = element.id; ajax( "GET","info.json?id="+id, function( result )&#123; callback(reslut) &#125;);&#125; 优点 接口和实现隔离，实现单一责任 提高可扩充性 实现的细节对用户隐藏 组合模式（Composite） 将对象组合成树形结构以表示整体-部分的管理，组合模式中只有两种类型对象，组合对象，叶子对象 上栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//组合对象function ImagesStore( id )&#123; this.children = []; this.element = document.createElement("div"); this.element.id = id; this.element.className = "imgs-store";&#125;ImagesStore.prototype = &#123; constructor ： ImagesStore， add : function( child )&#123; this.children.push( child ); this.element.appendChild( child.getElement() ); &#125;, remove : function( child )&#123; for( var node, i=0; node = this.getChild(i); i++ )&#123; if( node === child )&#123; this.children.splice( i, 1 ); break; &#125; this.element.removeChild( child.getElement() ); &#125; &#125;, getChild : function( i )&#123; return this.children[i]; &#125;, show : function()&#123; this.element.style.display = ''; for( var node, i=0; node = this.getChild(i); i++ )&#123; node.show(); &#125; &#125;, hide : function()&#123; for( var node, i=0; node = this.getChild(i); i++ )&#123; node.hide(); &#125; this.element.style.display = 'none'; &#125;, getElement : function()&#123; return this.element; &#125;&#125;//叶子对象function ImageItem( src )&#123; this.element = document.createElement("img"); this.element.src = src; this.element.className = "img-item";&#125;ImageItem.prototype = &#123; constructor ： ImagesStore， add : function( child )&#123; throw new Error("this is image object, no add function"); &#125;, remove : function( child )&#123; throw new Error("this is image object, no remove function"); &#125;, getChild : function( i )&#123; throw new Error("this is image object, no getChild function"); &#125;, show : function()&#123; this.element.style.display = ''; &#125;, hide : function()&#123; this.element.style.display = 'none'; &#125;, getElement : function()&#123; return this.element; &#125;&#125;//组合var store = new ImagesStore("first");store.add( new ImageItem("/img/1.jpg") );store.add( new ImageItem("/img/2.jpg") ); 使用场景 你想表示对象的部分-整体层次结构时； 你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法） 装饰器模式（Decorator） 在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象。 在没有使用模式之前，对于一个js小白来讲，创建一个父类，通过不同的子类来实现不同的功能，这也是面向对象的思想，思路是正确的，可是你有没有想过后期的维护呢？如果功能少还好，功能很多就要写很多个子类，同时如果需要扩展也要重新定义子类 12345678910//父类var Car = function()&#123;&#125;//不同公共的子类子类var CarWithPowerLocks = function() &#123;...&#125;;var CarWithPowerWindows = function() &#123;...&#125;;var CarWithPowerLocksAndPowerWindows = function() &#123;...&#125;;var CarWithAC = function() &#123;...&#125;;var CarWithACAndPowerLocks = function() &#123;...&#125;;var CarWithACAndPowerWindows = function() &#123;...&#125;;var CarWithACAndPowerLocksAndPowerWindows = function() &#123;...&#125;; 下面使用装饰者模式来拯救你的不可维护的代码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//创建一个基类Carvar Car = functionn()&#123;&#125;Car.prortype=&#123; start: function() &#123; console.log('伴随着引擎的轰鸣声，车子发动了！'); &#125;, drive: function() &#123; console.log('走起!'); &#125;, getPrice: function() &#123; return 11000.00; &#125;&#125;//创建装饰者抽象类// 你需要传递一个Car（或者是CarDecorator）才能为它添加功能。var CarDecorator = function(car) &#123; this.car = car;&#125;// CarDecorator 实现相同的接口CarDecorator.prototype = &#123; start: function() &#123; this.car.start(); &#125;, drive: function() &#123; this.car.drive(); &#125;, getPrice: function() &#123; return this.car.getPrice(); &#125;&#125;//具体的装饰者类var PowerLocksDecorator = function(car) &#123; // 这是JavaScript里调用父类构造函数的方式 CarDecorator.call(this, car); console.log('装配：添加动力锁');&#125;PowerLocksDecorator.prototype = new CarDecorator();PowerLocksDecorator.prototype.drive = function() &#123; // 你可以这么写 this.car.drive(); // 或者你可以调用父类的drive方法： // CarDecorator.prototype.drive.call(this); console.log('车门自动上锁');&#125;var PowerWindowsDecorator = function(car) &#123; CarDecorator.call(this, car); console.log('装配：添加动力表盘');&#125;PowerWindowsDecorator.prototype = new CarDecorator();var ACDecorator = function(car) &#123; CarDecorator.call(this, car); console.log('装配：添加空调');&#125;ACDecorator.prototype = new CarDecorator();ACDecorator.prototype.start = function() &#123; this.car.start(); console.log('冷风吹起来');&#125; 这样我们每次新增功能，都可以确保基类和装饰类不改变，只需要通过具体的装饰类来扩展功能就好。感觉和组合模式很像，组合模式侧重部分-整体，将部分注入到整体中，而装饰者模式是通过具体的装饰者类实现角色的基本功能并添加额外功能 看完栗子，来总结一下： 装饰者模式的几大要素 角色（Component）:定义了接口，规范准备接受的对象（Car） 装饰角色（Decorator）：持有角色（Component）的实例，定义与角色一致的接口（CarDecorator） 具体装饰着（PowerLocksDecorator）:负责给角色添加附加功能 优点 装饰类和被装饰类可以独立发展，不会相互耦合 装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。就增加功能来说，装饰器模式相比生成子类更为灵活。 使用场景 扩展一个类的功能。 动态增加功能，动态撤销。 使用了 开闭原则 这里讲解很精彩 外观模式（Facede） 门面模式本质是实现一个简单的统一接口来处理对各个子系统接口的处理和调用 这里我们来回忆一下之前说过的桥接模式，两者感觉差不多，实际侧重点并不相同。桥接模式侧重于各个类相互独立，而外观模式侧重于接口和内部实现的分离，我们只需要知道怎样调用接口无需知道内部的实现过程。 上栗子：模拟电脑启动，假设电脑启动顺序：启动CPU，启动内存，启动硬盘，加载数据等。 123456789101112131415161718192021222324252627282930// 外观模式 function CPU() &#123; this.startup = function () &#123; console.log("启动CPU"); &#125;;&#125;function Memory() &#123; this.startup = function () &#123; console.log("启动Memory"); &#125;;&#125;function Disk() &#123; this.startup = function () &#123; console.log("启动Disk"); &#125;;&#125;function Computer() &#123; var _cpu, _memory, _disk; _cpu = new CPU(); _memory = new Memory(); _disk = new Disk(); this.start = function () &#123; _cpu.startup(); _memory.startup(); _disk.startup(); &#125;&#125;computer = new Computer();computer.start(); 优点 1.减少系统相互依赖。2.提高灵活性。2.提高了安全性。 使用场景 1.为复杂的模块或子系统提供外界访问的模块。2.客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 享元模式（Flyweight）​ 代理模式（Proxy） 行为设计模式（Behavioral） 解释器（Interpreter） 模板方法（Template Method） 职责链（Responsibility） 命令（Command） 迭代器（Iterator） 中介者（Mediator） 观察者（Observe） 状态（State） 策略（Strategy） 访问者（Visitor）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bookmarks使用]]></title>
      <url>%2F2016%2F09%2F01%2Fbookmarks%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[bookmarks可以很便利的存储、管理我们日常使用的网站，一般情况下，我们仅仅是把自己的网站存在自己的bookmarks下面，以便自己日后查看。在团队中，多多向别人学习，看看别人的代码，瞅瞅别人经常浏览的网站，通过这种方式找到学习的方向，提升自己，特别是对菜鸟，会提供方向性的指导，多浏览一下质量高的网站，对自己的提高帮助很大的。 安装npm install netscape-bookmarks npm install netscape-bookmarks 使用 12345678var netscape = require('netscape-bookmarks');var bookmarks = &#123; 'Dave Eddy': 'http://www.daveeddy.com', 'Perfume Global': 'http://www.perfume-global.com'&#125;;var html = netscape(bookmarks));console.log(html); copy html格式文件，html标签说明 123456789101112131415161718192021&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt;&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"&gt;&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;&lt;H1&gt;Bookmarks Menu&lt;/H1&gt;&lt;DL&gt;&lt;p&gt; // 书签列表 &lt;DT&gt;&lt;A HREF="http://www.daveeddy.com"&gt;Dave Eddy's Blog&lt;/a&gt; // 书签项 &lt;DT&gt;&lt;A HREF="http://www.perfume-global.com/"&gt;Perfume Global&lt;/a&gt; &lt;DT&gt;&lt;H3&gt;Unfiled&lt;/H3&gt; // 书签文件夹 &lt;DL&gt;&lt;p&gt; &lt;DT&gt;&lt;A HREF="http://twitter.com"&gt;Twitter&lt;/a&gt; // 书签项 &lt;/DL&gt;&lt;p&gt; &lt;DT&gt;&lt;H3&gt;Second Folder&lt;/H3&gt; &lt;DL&gt;&lt;p&gt; &lt;DT&gt;&lt;H3&gt;Nested Folders!&lt;/H3&gt; &lt;DL&gt;&lt;p&gt; &lt;DT&gt;&lt;A HREF="http://www.youtube.com"&gt;YouTube&lt;/a&gt; &lt;DT&gt;&lt;A HREF="https://github.com"&gt;GitHub&lt;/a&gt; &lt;/DL&gt;&lt;p&gt; &lt;/DL&gt;&lt;p&gt; &lt;DT&gt;&lt;A HREF="http://www.tekzoned.com" ADD_DATE="1357547237" LAST_VISIT="1357547238" LAST_MODIFIED="1357547239"&gt;TekZoned&lt;/a&gt;&lt;/DL&gt;&lt;p&gt; 浏览器-书签管理器-从html文件导入书签]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript模板引擎]]></title>
      <url>%2F2016%2F08%2F31%2FjavascriptTemplate%2F</url>
      <content type="text"><![CDATA[简介 javascript模板引擎作为数据与界面分离工作中的重要角色，下面我们从模板引擎的实现原理以及目前流行的模板引擎，模板引擎的优势来介绍一下 原理虽然每个引擎从模板语法、语法解析、变量赋值、字符串拼接的实现方式各有所不同，但关键的渲染原理仍然是动态执行 javascript 字符串。 优势 js模板的本质是 变静为动 视图和代码逻辑分离、低耦合 可拓展、可维护、开发效率高 代码可读性 目前流行的 JavaScript模板引擎 artTemplate(腾讯) Mustache baiduTemplate(百度) juicer(淘宝) Underscore Templates Embedded JS Templates等等，可以参考这里五款流行的JavaScript模板引擎;javascript各种模板引擎; 使用 以 （EJS）Embedded JS Templates为例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用hexo+GitHub搭建自己的博客]]></title>
      <url>%2F2016%2F08%2F31%2F%E4%BD%BF%E7%94%A8hexo-GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[作为一名前端程序媛，没有自己的博客，听起来是不是很low！ 对，你没有听错，我确实没有亲自搭建过自己的博客，就在2016年8月30日，偶尔阅读前端工程师必备技能的时候，发现了搭建自己博客这个东西，于是决定搭建一个博客来存储自己的知识总结，以便形成自己的知识体系。这之前使用github我的github地址管理自己的代码（其实写的比较少）,而且很多知识性的总结写在里面不是很方便阅读。博客可以很方便的把知识总结存储起来。以前用过CSDN,用于存储知识还是可以，但是本地化和主题等就没有了，毕竟是用人家的网站，要想个性化还是要自己亲自去搭建一个高大上的网站吧。你正在浏览这个博客网站，耗费了本姑娘很长时间才搭建好的！！ 这里有一篇很详细的教程：使用 GitHub Pages + Hexo 基础教程;因为还没有写过正式的博客，对于hexo的使用还不熟悉，后面将更新我的的使用心得。]]></content>
    </entry>

    
  
  
</search>
